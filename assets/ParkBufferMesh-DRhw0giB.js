import{j as e,a as n,I as t,D as r,d as i,e as o,V as c}from"./three-V9KlXHdT.js";import{b as u}from"./vendor-CPR9a7GK.js";import{P as a}from"./Footer-jmf9Sd_V.js";function l({meshType:n}){const t=u.useRef(),{positions:r,reference:i}=u.useMemo(()=>{const e=n;if(!e)return{positions:new Float32Array,reference:new Float32Array};const t=e.attributes.position.array,r=e.attributes.position.count,i=new Float32Array(3*r),o=new Float32Array(2*r);for(let n=0;n<r;n++){let e=t[3*n+0]/100,c=t[3*n+1]/100,u=t[3*n+2]/100;i[3*n+0]=e,i[3*n+1]=c,i[3*n+2]=u,o[2*n+0]=n%r/r,o[2*n+1]=~~(n/r)/r}return{positions:i,reference:o}});return e.jsxs("bufferGeometry",{ref:t,children:[e.jsx("bufferAttribute",{attach:"attributes-position",count:r.length/3,array:r,itemSize:3}),e.jsx("bufferAttribute",{attach:"attributes-reference",name:"reference",array:i,count:i.length/2,itemSize:2})]})}var s="uniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_mouseInfluence;\n\nuniform vec4 u_mouseClick; \nuniform float u_clickInfluence;\nuniform float u_clickWaveSpeed;\nuniform float u_clickDecayRate;\n\nuniform float frequency;\nuniform float amplitude;\nuniform float maxDistance;\n\nuniform float noiseScale;\nuniform float noiseDensity;\nuniform float noiseOctaves;\nuniform float noiseLacunarity;\nuniform float noiseGain;\nuniform float turbulenceStrength;\nuniform float flowDirection;\nuniform float waveSpeed;\nuniform float distortionStrength;\n\nuniform float mouseOrderRadius;\nuniform float mouseOrderStrength;\nuniform float chaosStrength;\n\nuniform float particleSize;\nuniform float colorIntensity;\n\nvarying vec2 vUv;\nattribute vec2 reference;\n\nfloat PI = 3.141592653589793238;\nuniform bool isMobile;\n\nfloat rand(vec2 c){\nreturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\nfloat unit = 1./freq;\nvec2 ij = floor(p/unit);\nvec2 xy = mod(p,unit)/unit;\n\nxy = .5*(1.-cos(PI*xy));\nfloat a = rand((ij+vec2(0.,0.)));\nfloat b = rand((ij+vec2(1.,0.)));\nfloat c = rand((ij+vec2(0.,1.)));\nfloat d = rand((ij+vec2(1.,1.)));\nfloat x1 = mix(a, b, xy.x);\nfloat x2 = mix(c, d, xy.x);\nreturn mix(x1, x2, xy.y);\n}\n\nvec3 mod289(vec3 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\nreturn mod289(((x*34.0)+1.0)*x);\n}\n\nfloat noise(vec2 v)\n{\nconst vec4 C = vec4(0.211324865405187,  \n                    0.366025403784439,  \n                -0.577350269189626,  \n                    0.024390243902439); \n\nvec2 i  = floor(v + dot(v, C.yy) );\nvec2 x0 = v -   i + dot(i, C.xx);\n\nvec2 i1;\n\ni1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\nvec4 x12 = x0.xyxy + C.xxzz;\nx12.xy -= i1;\n\ni = mod289(i); \nvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\nvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\nm = m*m ;\nm = m*m ;\n\nvec3 x = 2.0 * fract(p * C.www) - 1.0;\nvec3 h = abs(x) - 0.5;\nvec3 ox = floor(x + 0.5);\nvec3 a0 = x - ox;\n\nm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\nvec3 g;\ng.x  = a0.x  * x0.x  + h.x  * x0.y;\ng.yz = a0.yz * x12.xz + h.yz * x12.yw;\nreturn 130.0 * dot(m, g);\n}\n\nvec3 curl(float x, float y, float z)\n{\n    float eps = 1.0 / noiseDensity, eps2 = 2.0 * eps;\n    float n1, n2, a, b;\n\n    \n    float timeOffset = u_time * waveSpeed * 0.05;\n    x += timeOffset;\n    y += timeOffset;\n    z += timeOffset;\n\n    \n    float flowRad = flowDirection * PI / 180.0;\n    vec2 flowVec = vec2(cos(flowRad), sin(flowRad)) * 0.1;\n    x += flowVec.x * u_time * waveSpeed;\n    y += flowVec.y * u_time * waveSpeed;\n\n    \n    x *= noiseScale;\n    y *= noiseScale;\n    z *= noiseScale;\n\n    vec3 curl = vec3(0.0);\n\n    \n    n1 = noise(vec2(x, y + eps));\n    n2 = noise(vec2(x, y - eps));\n    a = (n1 - n2) / eps2;\n\n    n1 = noise(vec2(x, z + eps));\n    n2 = noise(vec2(x, z - eps));\n    b = (n1 - n2) / eps2;\n\n    curl.x = (a - b) * turbulenceStrength;\n\n    n1 = noise(vec2(y, z + eps));\n    n2 = noise(vec2(y, z - eps));\n    a = (n1 - n2) / eps2;\n\n    n1 = noise(vec2(x + eps, z));\n    n2 = noise(vec2(x - eps, z));\n    b = (n1 - n2) / eps2;\n\n    curl.y = (a - b) * turbulenceStrength;\n\n    n1 = noise(vec2(x + eps, y));\n    n2 = noise(vec2(x - eps, y));\n    a = (n1 - n2) / eps2;\n\n    n1 = noise(vec2(y + eps, z));\n    n2 = noise(vec2(y - eps, z));\n    b = (n1 - n2) / eps2;\n\n    curl.z = (a - b) * turbulenceStrength;\n\n    return curl;\n}\n\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude_local = noiseGain;\n    float frequency_local = 1.0;\n    \n    for (int i = 0; i < int(noiseOctaves); i++) {\n        value += amplitude_local * noise(p * frequency_local);\n        p *= noiseLacunarity;\n        amplitude_local *= noiseGain;\n    }\n    return value;\n}\n\nvec3 calculateClickEffect(vec3 position) {\n    if (u_mouseClick.w < 0.5) return vec3(0.0); \n    \n    \n    vec2 clickPos = u_mouseClick.xy;\n    vec3 clickPos3D = vec3((clickPos.x - 0.5) * 2.0, (clickPos.y - 0.5) * 2.0, 0.0);\n    \n    \n    float dist = distance(position.xy, clickPos3D.xy);\n    \n    \n    float timeSinceClick = u_mouseClick.z;\n    \n    \n    float waveRadius = timeSinceClick * u_clickWaveSpeed;\n    float waveThickness = 0.3; \n    \n    \n    float waveIntensity = 1.0 - abs(dist - waveRadius) / waveThickness;\n    waveIntensity = max(0.0, waveIntensity);\n    \n    \n    float decay = exp(-timeSinceClick * u_clickDecayRate);\n    waveIntensity *= decay;\n    \n    \n    vec3 direction = normalize(position - clickPos3D);\n    \n    \n    return direction * waveIntensity * u_clickInfluence;\n}\n\nvoid main() {\n    vUv = reference;\n\n    vec3 newPos = position;\n\n    \n    \n    \n    vec4 screenPos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    vec2 screenCoord = (screenPos.xy / screenPos.w) * 0.5 + 0.5; \n    \n    \n    vec2 mousePos = u_mouse;\n    float distanceToMouse = length(screenCoord - mousePos);\n    \n    \n    float orderInfluence = 1.0 - smoothstep(0.0, mouseOrderRadius, distanceToMouse);\n    orderInfluence = smoothstep(0.0, 1.0, orderInfluence); \n    \n    \n    \n    float chaosFrequency = frequency;           \n    float chaosAmplitude = amplitude;           \n    float chaosMaxDistance = maxDistance;       \n    \n    \n    float orderFrequency = 0.008;              \n    float orderAmplitude = 2.0;                \n    float orderMaxDistance = 3.0;              \n    \n    \n    float dynamicFrequency = mix(chaosFrequency, orderFrequency, orderInfluence);\n    float dynamicAmplitude = mix(chaosAmplitude, orderAmplitude, orderInfluence);\n    float dynamicMaxDistance = mix(chaosMaxDistance, orderMaxDistance, orderInfluence);\n    \n    \n    float dynamicTurbulence = mix(turbulenceStrength, turbulenceStrength * 0.1, orderInfluence);\n    float dynamicDistortion = mix(distortionStrength, distortionStrength * 0.2, orderInfluence);\n    float dynamicNoiseScale = mix(noiseScale, noiseScale * 0.3, orderInfluence);\n    float dynamicWaveSpeed = mix(waveSpeed, waveSpeed * 0.3, orderInfluence);\n    \n    \n    vec3 noisePos = newPos * dynamicFrequency * dynamicNoiseScale;\n    vec3 curlForce = curl(noisePos.x, noisePos.y, noisePos.z);\n    \n    \n    curlForce *= dynamicTurbulence;\n    \n    \n    float fbmNoise = fbm(noisePos.xy + u_time * dynamicWaveSpeed * 0.05);\n    curlForce += vec3(fbmNoise) * (0.5 * (1.0 - orderInfluence * 0.9)); \n    \n    \n    vec3 target = position + curlForce * dynamicAmplitude * dynamicDistortion;\n    \n    \n    vec3 clickEffect = calculateClickEffect(position);\n    target += clickEffect;\n    \n    \n    float d = length(position - target) / dynamicMaxDistance;\n    vec3 finalPos = mix(position, target, pow(d, 3.0)); \n\n    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0); \n    \n    \n    gl_PointSize = particleSize * (1.0 / -mvPosition.z);\n    if (isMobile) {\n        gl_PointSize = particleSize * 2.0 * (1.0 / -mvPosition.z);\n    }\n    gl_Position = projectionMatrix * mvPosition;\n}",f="uniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float colorIntensity;\nuniform vec3 particleColor;\nuniform float mouseOrderRadius;\n\nvarying vec2 vUv;\nfloat PI = 3.141592653589793238; \n\nvoid main() {\n    \n    vec2 pointCoord = gl_PointCoord.xy - vec2(0.5);\n    float dist = length(pointCoord);\n    \n    \n    if (dist > 0.5) {\n        discard;\n    }\n    \n    \n    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);\n    \n    \n    vec3 finalColor = particleColor; \n    \n    \n    finalColor *= colorIntensity;\n    \n    gl_FragColor = vec4(finalColor, alpha);\n}";const m=u.forwardRef(function({geoComplexity:a=100,meshType:m=new t(100,a),particleColor:v=[1,1,1],meshPosition:d=[0,0,0],meshRotation:y=[0,0,0],frequency:p=.175,amplitude:x=3.5,maxDistance:w=2.85,timeSpeed:S=.5,noiseScale:h=1,noiseDensity:g=1,particleSize:_=1,colorIntensity:k=1,mouseInfluenceStrength:C=1,clickInfluenceStrength:I=2,clickWaveSpeed:D=3,clickDecayRate:b=.8,noiseOctaves:z=3,noiseLacunarity:P=2,noiseGain:R=.5,turbulenceStrength:E=1,flowDirection:j=0,waveSpeed:q=1,distortionStrength:M=1},A){const F=u.useRef(),T=u.useRef({x:.5,y:.5}),[L,O]=u.useState(C),N=u.useRef({x:.5,y:.5,time:0,active:!1}),[W,G]=u.useState(I),[V,B]=u.useState(D),[X,Y]=u.useState(b),U=u.useRef(0);return n(({clock:e})=>{if(e&&F.current&&(U.current=e.elapsedTime,F.current&&F.current.uniforms)){const n=e.elapsedTime*S;if(F.current.uniforms.u_time.value=n,F.current.uniforms.u_mouse.value.set(T.current.x,T.current.y),F.current.uniforms.u_mouseInfluence.value=L,F.current.uniforms.u_mouseClick.value.set(N.current.x,N.current.y,N.current.time,N.current.active?1:0),F.current.uniforms.u_clickInfluence.value=W,F.current.uniforms.u_clickWaveSpeed.value=V,F.current.uniforms.u_clickDecayRate.value=X,N.current.active){e.elapsedTime-N.current.time>3&&(N.current.active=!1)}F.current.uniforms.particleColor.value.set(v[0],v[1],v[2])}}),u.useEffect(()=>{function e(e){if(e&&e.target)try{const n=e.target.getBoundingClientRect();if(!n)return;T.current.x=(e.clientX-n.left)/n.width,T.current.y=1-(e.clientY-n.top)/n.height}catch(n){}}function n(e){if(e&&e.target)try{if(!e.target.tagName||"CANVAS"!==e.target.tagName&&!e.target.closest("canvas"))return;const n=e.target.getBoundingClientRect();if(!n)return;N.current.x=(e.clientX-n.left)/n.width,N.current.y=1-(e.clientY-n.top)/n.height,N.current.time=U.current,N.current.active=!0}catch(n){}}return"undefined"!=typeof window&&(window.addEventListener("mousemove",e),window.addEventListener("click",n)),()=>{"undefined"!=typeof window&&(window.removeEventListener("mousemove",e),window.removeEventListener("click",n))}},[]),u.useEffect(()=>{F.current&&F.current.uniforms.particleColor&&F.current.uniforms.particleColor.value.set(v[0],v[1],v[2])},[v]),u.useEffect(()=>{F.current&&F.current.uniforms.frequency&&(F.current.uniforms.frequency.value=p)},[p]),u.useEffect(()=>{F.current&&F.current.uniforms.amplitude&&(F.current.uniforms.amplitude.value=x)},[x]),u.useEffect(()=>{F.current&&F.current.uniforms.maxDistance&&(F.current.uniforms.maxDistance.value=w)},[w]),u.useEffect(()=>{F.current&&F.current.uniforms.u_time},[S]),e.jsxs("points",{ref:A,position:d,rotation:y,children:[e.jsx(l,{meshType:m}),e.jsx("shaderMaterial",{ref:F,uniforms:{u_time:{value:0},u_resolution:{value:new c},frequency:{type:"f",value:p},amplitude:{type:"f",value:x},maxDistance:{type:"f",value:w},noiseScale:{type:"f",value:h},noiseDensity:{type:"f",value:g},particleSize:{type:"f",value:_},colorIntensity:{type:"f",value:k},u_mouse:{value:new c(.5,.5)},u_mouseInfluence:{value:L},u_mouseClick:{value:new o(.5,.5,0,0)},u_clickInfluence:{value:W},u_clickWaveSpeed:{value:V},u_clickDecayRate:{value:X},particleColor:{value:new i(v[0],v[1],v[2])},noiseOctaves:{type:"f",value:z},noiseLacunarity:{type:"f",value:P},noiseGain:{type:"f",value:R},turbulenceStrength:{type:"f",value:E},flowDirection:{type:"f",value:j},waveSpeed:{type:"f",value:q},distortionStrength:{type:"f",value:M}},side:r,vertexShader:s,fragmentShader:f})]})}),v=u.forwardRef(function({geoComplexity:l=100,meshType:m=new t(100,l),particleColor:v=[1,1,1],meshPosition:d=[0,0,0],meshRotation:y=[0,-2.1,0],frequency:p=.175,amplitude:x=3.5,maxDistance:w=2.85,timeSpeed:S=.5,noiseScale:h=1,noiseDensity:g=1,particleSize:_=1,colorIntensity:k=1,mouseInfluenceStrength:C=1,clickInfluenceStrength:I=2,clickWaveSpeed:D=3,clickDecayRate:b=.8,noiseOctaves:z=3,noiseLacunarity:P=2,noiseGain:R=.5,turbulenceStrength:E=1,flowDirection:j=0,waveSpeed:q=1,distortionStrength:M=1},A){const F=u.useRef(),T=u.useRef({x:.5,y:.5}),[L,O]=u.useState(C),N=u.useRef({x:.5,y:.5,time:0,active:!1}),[W,G]=u.useState(I),[V,B]=u.useState(D),[X,Y]=u.useState(b),U=u.useRef(0);return n(({clock:e})=>{if(U.current=e.elapsedTime,F.current){const n=e.elapsedTime*S;if(F.current.uniforms.u_time.value=n,F.current.uniforms.u_mouse.value.set(T.current.x,T.current.y),F.current.uniforms.u_mouseInfluence.value=L,F.current.uniforms.u_mouseClick.value.set(N.current.x,N.current.y,N.current.time,N.current.active?1:0),F.current.uniforms.u_clickInfluence.value=W,F.current.uniforms.u_clickWaveSpeed.value=V,F.current.uniforms.u_clickDecayRate.value=X,N.current.active){e.elapsedTime-N.current.time>3&&(N.current.active=!1)}F.current.uniforms.particleColor.value.set(v[0],v[1],v[2])}}),u.useEffect(()=>{function e(e){if(e&&e.target)try{const n=e.target.getBoundingClientRect();if(!n)return;T.current.x=(e.clientX-n.left)/n.width,T.current.y=1-(e.clientY-n.top)/n.height}catch(n){}}function n(e){if(e&&e.target)try{if(!e.target.tagName||"CANVAS"!==e.target.tagName&&!e.target.closest("canvas"))return;const n=e.target.getBoundingClientRect();if(!n)return;N.current.x=(e.clientX-n.left)/n.width,N.current.y=1-(e.clientY-n.top)/n.height,N.current.time=U.current,N.current.active=!0}catch(n){}}return"undefined"!=typeof window&&(window.addEventListener("mousemove",e),window.addEventListener("click",n)),()=>{"undefined"!=typeof window&&(window.removeEventListener("mousemove",e),window.removeEventListener("click",n))}},[]),u.useEffect(()=>{F.current&&F.current.uniforms.particleColor&&F.current.uniforms.particleColor.value.set(v[0],v[1],v[2])},[v]),u.useEffect(()=>{F.current&&F.current.uniforms.frequency&&(F.current.uniforms.frequency.value=p)},[p]),u.useEffect(()=>{F.current&&F.current.uniforms.amplitude&&(F.current.uniforms.amplitude.value=x)},[x]),u.useEffect(()=>{F.current&&F.current.uniforms.maxDistance&&(F.current.uniforms.maxDistance.value=w)},[w]),u.useEffect(()=>{F.current&&F.current.uniforms.u_time},[S]),e.jsxs("points",{ref:A,rotation:y,position:d,children:[e.jsx(a,{}),e.jsx("shaderMaterial",{ref:F,uniforms:{u_time:{value:0},u_resolution:{value:new c},frequency:{type:"f",value:p},amplitude:{type:"f",value:x},maxDistance:{type:"f",value:w},noiseScale:{type:"f",value:h},noiseDensity:{type:"f",value:g},particleSize:{type:"f",value:_},colorIntensity:{type:"f",value:k},u_mouse:{value:new c(.5,.5)},u_mouseInfluence:{value:L},u_mouseClick:{value:new o(.5,.5,0,0)},u_clickInfluence:{value:W},u_clickWaveSpeed:{value:V},u_clickDecayRate:{value:X},particleColor:{value:new i(v[0],v[1],v[2])},noiseOctaves:{type:"f",value:z},noiseLacunarity:{type:"f",value:P},noiseGain:{type:"f",value:R},turbulenceStrength:{type:"f",value:E},flowDirection:{type:"f",value:j},waveSpeed:{type:"f",value:q},distortionStrength:{type:"f",value:M}},side:r,vertexShader:s,fragmentShader:f})]})});export{m as I,v as P,l as a};
